#! py -3
# -*- coding: LATIN_1 -*-

import os, sys
import xml.etree.ElementTree as ET
import copy

def mk_identifier(s):
	tmp = ''
	for ch in s:
		if not tmp:
			if ch.isalpha() or (ch == '_'):
				tmp += ch
			else:
				tmp += '_'
		elif ch.isalnum() or (ch == '_'):
			tmp += ch
		else:
			tmp += '_'
	return tmp

def extract_lo(str):
	w = int(str, 0) & 0xFF
	return hex(w)

def extract_hi(str):
	w = (int(str, 0) >> 8) & 0xFF
	return hex(w)

def DoHfileStart(fh=sys.stdout):
	fh.write("""/////////////////////////////////////////////////////////////////////////////////////
// THIS FILE WAS AUTOMATICALLY GENERATED BY **ExtraChipInfo.py** SCRIPT!
// DO NOT EDIT!
/////////////////////////////////////////////////////////////////////////////////////
// Information extracted from:
// MSPDebugStack_OS_Package_3_15_1_1.zip\DLL430_v3\src\TI\DLL430\DeviceDb\devicedb.h
/////////////////////////////////////////////////////////////////////////////////////

/*
 * C:\MSP430\mspdebugstack\DLL430_v3\src\TI\DLL430\DeviceDb\devicedb.h
 *
 * Copyright (C) 2020 Texas Instruments Incorporated - http://www.ti.com/
 *
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

namespace ChipInfoDB {

//! Signals that start address field of the record is undefined
#define NO_MEM_START	0xFFFFFFFF	// an odd value is impossible
//! Signals the the main ID field of the record is undefined
#define NO_MCU_ID0		0xFFFF
//! Signals the the ID info field byte of the record is undefined
#define EMPTY_INFO_SLOT	0xFF

#pragma pack(1)

enum MemoryClass : uint8_t
{
	kClasMain
	, kClasRam
	, kClasRam2
	, kClasTinyRam
	, kClasLeaRam
	, kClasInfo
	, kClasCpu
	, kClasIrVec
	, kClasLcd
	, kClasEem
	, kClasBootCode
	, kClasBootCode2
	, kClasBsl
	, kClasBsl2
	, kClasMidRom
	, kClasUsbRam
	, kClasPeripheral8bit
	, kClasPeripheral16bit
	, kClasPeripheral16bit1
	, kClasPeripheral16bit2
	, kClasPeripheral16bit3
	, kClasUssPeripheral
	, kClasLeaPeripheral
	, kClasLib
	, kClasMax_
};

enum MemoryType : uint8_t
{
	kNullMemType
	, kRegister
	, kFlash
	, kRam
	, kRom
	, kMemTypeMax
};

enum MemAccessType : uint8_t
{
	kNullMemAccess
	, kBootcodeRomAccess
	, kBslRomAccess
	, kBslRomAccessGR
	, kBslFlashAccess
	, kFlashMemoryAccess2ByteAligned
	, kInformationFlashAccess
	, kFramMemoryAccessBase
	, kFramMemoryAccessFRx9
	, kTinyRandomMemoryAccess
	, kLockableRamMemoryAccess
	, kUsbRamAccess
	, kRegisterAccess5xx
	, kMemAccessMax
};

enum PsaType : uint8_t
{
	kNullPsaType
	, kRegular
	, kEnhanced
	, kPsaMax
};

enum CpuArchitecture : uint8_t
{
	kNullArchitecture
	, kCpu
	, kCpuX
	, kCpuXv2
};

enum EemType : uint8_t
{
	kNullEem
	, kEMEX_LARGE_5XX
	, kEemMax_
};

enum BitSize : uint8_t
{
	kNullBitSize
	, k8
	, k16
	, k20
};

enum ConfigMask : uint8_t
{
	kCfgNoMask		// 0xFF
	, kCfg7F		// 0x7F
};

enum FusesMask : uint8_t
{
	kFuseNoMask		// 0xF
	, kFuse1F		// 0x1F
	, kFuse07		// 0x7
	, kFuse03		// 0x3
	, kFuse01		// 0x1
};

enum SubversionPresence : uint8_t
{
	kNoSubversion
	, kUseSubversion
};

enum SelfPresence : uint8_t
{
	kNoSelf
	, kUseSelf
};

enum RevisionPresence : uint8_t
{
	kNoRevision
	, kUseRevision
};

enum ConfigPresence : uint8_t
{
	kNoConfig
	, kUseConfig
};

enum FabPresence : uint8_t
{
	kNoFab
	, kUseFab
};

enum FusesPresence : uint8_t
{
	kNoFuses
	, kUseFuses
};

struct MemoryInfo
{
	const MemoryInfo *ref_;
	uint32_t start_;
	uint32_t size_;
	MemoryType type_ : 3;
	BitSize bit_size_ : 3;
	uint8_t mapped_ : 1;
	uint8_t access_mpu_ : 1;
	uint8_t banks_ : 4;
	MemAccessType access_type_ : 4;
};

struct MemoryClasInfo
{
	MemoryClass class_;
	const MemoryInfo *info_;
};

struct MemoryLayoutInfo
{
	const MemoryLayoutInfo *ref_;
	uint32_t entries_;
	const MemoryClasInfo array_[];
};

struct Device
{
	const Device *ref_;					// 0
	const char *name_;					// 4
	const MemoryLayoutInfo *mem_layout_;// 8
	uint16_t mcu_ver_;					// 12: version
	uint8_t mcu_misc_0;					// 14: a misc of revision, config, fab, self...
	uint8_t mcu_misc_1;					// 15
	uint8_t mcu_misc_2;					// 16
	uint8_t mcu_misc_3;					// 17
	// mask to control misc, in order
	FusesMask mcu_fuse_mask : 3;		// 18
	ConfigMask mcu_cfg_mask : 1;
	SubversionPresence mcu_sub_f : 1;
	SelfPresence mcu_self_f : 1;
	RevisionPresence mcu_rev_f : 1;
	ConfigPresence mcu_cfg_f : 1;
	FabPresence mcu_fab_f : 1;			// 19
	FusesPresence mcu_fuse_f : 1;
	BitSize bits_ : 2;
	CpuArchitecture arch_ : 2;
	PsaType psa_ : 2;
};

struct DeviceList
{
	uint32_t entries_;
	const Device *array_[];
};

#pragma pack()

// A single file should enable this macro to implement the database
#ifdef OPT_IMPLEMENT_DB

""")

def DoHfileStop(fh=sys.stdout):
	fh.write("""
#else	// OPT_IMPLEMENT_DB

extern const DeviceList all_msp430_mcus;

#endif	// OPT_IMPLEMENT_DB

}\t// namespace ChipInfoDB

""")


class Memory(object):
	def __init__(self, node, mems):
		super().__init__()
		if "ref" in node.attrib:
			self.ref = mems.ResolveId(Memory.GetIdent(node.attrib["ref"]))
		else:
			self.ref = None
		self.start = None
		self.size = None
		self.type = None
		self.bits = None
		self.banks = None
		self.mapped = None
		self.access_type = None
		self.access_mpu = None
		for a in node:
			if a.tag == "type":
				self.type = a.text
			elif a.tag == "bits":
				self.bits = a.text
			elif a.tag == "start":
				self.start = a.text
			elif a.tag == "size":
				self.size = a.text
			elif a.tag == "banks":
				self.banks = a.text
			elif a.tag == "mapped":
				self.mapped = a.text
			elif a.tag == "memoryAccess":
				for k in a:
					if k.tag == "type":
						self.access_type = k.text
					elif k.tag == "mpu":
						self.access_mpu = k.text
	def IsPure(self):
		if self.ref is None:
			return False
		return (self.type is None) \
			and (self.bits is None) \
			and (self.start is None) \
			and (self.size is None) \
			and (self.banks is None) \
			and (self.mapped is None) \
			and (self.access_type is None) \
			and (self.access_mpu is None)

	def __eq__(self, value):
		return (self.ref == value.ref) \
			and (self.start == value.start) \
			and (self.size == value.size) \
			and (self.type == value.type) \
			and (self.bits == value.bits) \
			and (self.banks == value.banks) \
			and (self.mapped == value.mapped) \
			and (self.access_type == value.access_type) \
			and (self.access_mpu == value.access_mpu)

	@staticmethod
	def GetIdent(id):
		return "mem_" + mk_identifier(id)

	def DoHfile(self, fh=sys.stdout):
		if self.ref:
			fh.write("\t&" + self.ref + "\n")
		else:
			fh.write("\tNULL\n")
		if self.start:
			fh.write("\t, " + self.start + "\n")
		else:
			fh.write("\t, NO_MEM_START\n")
		if self.size:
			fh.write("\t, " + self.size + "\n")
		else:
			fh.write("\t, 0\n")
		if self.type:
			fh.write("\t, k" + self.type + "\n")
		else:
			fh.write("\t, kNullMemType\n")
		if self.bits:
			fh.write("\t, k" + self.bits + "\n")
		else:
			fh.write("\t, kNullBitSize\n")
		if self.mapped:
			fh.write("\t, " + self.mapped + "\n")
		else:
			fh.write("\t, 0\n")
		if self.access_mpu:
			fh.write("\t, " + self.access_mpu + "\n")
		else:
			fh.write("\t, 0\n")
		if self.banks:
			fh.write("\t, " + self.banks + "\n")
		else:
			fh.write("\t, 0\n")
		if self.access_type:
			fh.write("\t, k" + self.access_type + "\n")
		else:
			fh.write("\t, kNullMemAccess\n")


class Memories(object):
	def __init__(self, root):
		super().__init__()
		self.Mems = {}
		self.Phys = []
		self.Alias = {}
		self.AddNode(root)

	def AddNode(self, node):
		for child in node:
			if child.tag == 'memory':
				id = Memory.GetIdent(child.attrib["id"])
				m = Memory(child, self)
				self.AddItem(id, m)

	def AddItem(self, id, m):
		for k in self.Mems:
			if m == self.Mems[k]:
				self.Alias[id] = k
				return k
		self.Phys.append(id)
		self.Mems[id] = m
		return id

	def ResolveId(self, id):
		if id in self.Alias:
			return self.Alias[id]
		return id

	def DoHfile(self, fh=sys.stdout):
		for n in self.Phys:
			o = self.Mems[n]
			fh.write("static const MemoryInfo " + n + " =\n{\n")
			o.DoHfile(fh)
			fh.write("};\n")


class MemoryLayout(object):
	def __init__(self, node, lid, lays, mems):
		super().__init__()
		self.ref = None
		if "ref" in node.attrib:
			self.ref = lays.ResolveId(MemoryLayout.GetIdent(node.attrib["ref"]))
		self.Mems = []
		for child in node:
			if child.tag == 'memory':
				clas = child.attrib["name"]
				mid = Memory.GetIdent(lid + '_' + clas)
				o = Memory(child, mems);
				if o.IsPure():
					self.Mems.append([clas, o.ref]);
				else:
					mid = mems.AddItem(mid, o)
					self.Mems.append([clas, mid]);
			else:
				raise Exception("Unexpected tag: " + child.tag)

	def __eq__(self, value):
		return (self.ref == value.ref) \
			and (self.Mems == value.Mems)

	@staticmethod
	def GetIdent(id):
		return "lyt_" + mk_identifier(id)

	def DoHfile(self, fh=sys.stdout):
		if self.ref:
			fh.write("\t&" + self.ref + "\n")
		else:
			fh.write("\tNULL\n")
		fh.write("\t, " + str(len(self.Mems)) + "\n\t, {\n")
		for i in self.Mems:
			fh.write("\t\t{{kClas{}, &{}}},\n".format(i[0], i[1]))
		fh.write("\t}\n")

class MemoryLayouts(object):
	def __init__(self, root, mems):
		super().__init__()
		self.Layouts = {}
		self.Alias = {}
		self.Phys = []
		self.AddNode(root, mems)

	def AddNode(self, node, mems):
		for child in node:
			if child.tag == 'memoryLayout':
				lid = MemoryLayout.GetIdent(child.attrib["id"])
				l = MemoryLayout(child, lid, self, mems)
				self.AddItem(lid, l)

	def AddItem(self, lid, l):
		for k in self.Layouts:
			if l == self.Layouts[k]:
				self.Alias[lid] = k
				return k
		self.Phys.append(lid);
		self.Layouts[lid] = l
		return lid

	def ResolveId(self, id):
		if id in self.Alias:
			return self.Alias[id]
		return id

	def AppendDeviceLayout(self, node, mems, id):
		found = None
		for child in node:
			if child.tag == 'memoryLayout':
				if found:
					raise Exception("Duplicate memory layout for " + id)
				if "id" in child.attrib:
					lid = MemoryLayout.GetIdent(node.attrib["id"])
				elif id:
					lid = MemoryLayout.GetIdent(id)
				else:
					raise Exception("Unable to determine an id for element")
				m = MemoryLayout(child, lid, self, mems)
				found = self.AddItem(lid, m);
		return found

	def DoHfile(self, fh=sys.stdout):
		for n in self.Layouts:
			o = self.Layouts[n]
			fh.write("static const MemoryLayoutInfo " + n + " =\n{\n")
			o.DoHfile(fh)
			fh.write("\n};\n")

class Device(object):
	def __init__(self, node, devs, lays, mems):
		super().__init__()
		self.ref = None
		self.name = None
		self.id = None
		self.version = None
		self.subversion = None
		self.revision = None
		self.config = None
		self.self_ = None
		self.fab = None
		self.fuses = None
		self.mconfig = None
		self.mfuses = None
		self.psa = None
		self.bits = None
		self.arch = None
		self.lay = None
		if "id" in node.attrib:
			self.id = "mcu_" + mk_identifier(node.attrib["id"])
		if "ref" in node.attrib:
			self.ref = "mcu_" + mk_identifier(node.attrib["ref"])
		scan_mem_layout = False
		for child in node:
			if child.tag == "description":
				self.name = child.text
			elif child.tag == "idCode":
				for v in child:
					if v.tag == "version":
						self.version = v.text
					elif v.tag == "subversion":
						self.subversion = v.text
					elif v.tag == "revision":
						self.revision = v.text
					elif v.tag == "config":
						self.config = v.text
					elif v.tag == "self":
						self.self_ = v.text
					elif v.tag == "fab":
						self.fab = v.text
					elif v.tag == "fuses":
						self.fuses = v.text
					elif v.tag in ("activationKey", "maxRevision"):
						pass
					else:
						raise Exception("Unexpected identification field " + v.tag + " in " + str(self.id))
			elif child.tag == "idMask":
				for v in child:
					if v.tag == "version":
						if int(v.text, 0) != 0xFFFF:
							raise Exception("Version mask support limited to 0xFFFF for current tool (" + v.tag + "/" + str(self.id) + ")")
					elif v.tag == "subversion":
						if int(v.text, 0) != 0xFFFF:
							raise Exception("Subversion mask support limited to 0xFFFF for current tool (" + v.tag + "/" + str(self.id) + ")")
					elif v.tag == "revision":
						if int(v.text, 0) != 0xFF:
							raise Exception("Revision mask support limited to 0xFF for current tool (" + v.tag + "/" + str(self.id) + ")")
					elif v.tag == "config":
						tmp = int(v.text, 0)
						if tmp not in (0x7F,0xFF):
							raise Exception("Config mask support limited to 0x7f or 0xFF values for current tool (" + v.tag + "/" + str(self.id) + ")")
						self.mconfig = v.text
					elif v.tag == "self":
						if int(v.text, 0) != 0xFFFF:
							raise Exception("Self mask support limited to 0xFFFF for current tool (" + v.tag + "/" + str(self.id) + ")")
					elif v.tag == "fab":
						if int(v.text, 0) != 0xFF:
							raise Exception("Fab mask support limited to 0xFF for current tool (" + v.tag + "/" + str(self.id) + ")")
					elif v.tag == "fuses":
						self.mfuses = v.text
					elif v.tag in ("activationKey", "maxRevision"):
						pass
					else:
						raise Exception("Unexpected identification field " + v.tag + " in " + str(self.id))
			elif child.tag == "psa":
				self.psa = child.text
			elif child.tag == "bits":
				self.bits = child.text
			elif child.tag == "architecture":
				self.arch = child.text
			elif child.tag == "memoryLayout":
				scan_mem_layout = True
		# Resolve empty ID here; use name but this could clash
		if self.id is None:
			if self.name:
				self.id = self.ResolveClashId("mcu_" + mk_identifier(self.name), devs)
			else:
				self.id = self.ResolveClashIdByRef(devs)
		# mem layout gets scanned only by fully resolved childs
		if scan_mem_layout:
			self.lay = lays.AppendDeviceLayout(node, mems, self.id)
		print(self.id, self.name)

	def ResolveClashId(self, base_id, devs):
		for ch in "!abcdefghijklmnopqrstuvwxyz":
			if ch != '!':
				id = base_id + '_' + ch
			else:
				id = base_id
			colision = False
			for d in devs:
				if d.id == id:
					colision = True
					break
			if not colision:
				return id
		raise Exception("cannot solve id in node " + self.name)

	def ResolveClashIdByRef(self, devs):
		# A reference is required if no id/name was provided
		if self.ref is None:
			raise Exception("cannot solve id in node " + self.name)
		refd = None
		for d in devs:
			if d.id == self.ref:
				refd = d
				break
		if not refd:
			raise Exception("cannot locate reference '{}' for '{}'".format(self.ref, self.name))
		return self.ResolveClashId(refd.id, devs)

	def __lt__(self, value):
		if self.name:
			if value.name:
				return self.name < value.name
			else:
				return False
		elif value.name:
			return True
		else:
			return self.id < value.id

	@staticmethod
	def put_mask_(fh, val, map):
		if val is not None:
			val = int(val, 0)
			if val not in map:
				fh.write("\t, " + hex(val) + "\n")	# usually produces a compiler error in C++
			else:
				fh.write("\t, " + map[val] + "\n")
		else:
			fh.write("\t, " + map[0] + "\n")
	@staticmethod
	def put_bool_mask_(fh, val, map):
		if val is not None:
			s = ", " + map[1]
			tabs = 6 - (len(s) // 4)
			if tabs <= 0:
				tabs = 1
			fh.write("\t" + s + '\t'*tabs + "// " + val + "\n")
		else:
			fh.write("\t, " + map[0] + "\n")

	def DoHfile(self, fh=sys.stdout):
		MAP_CONFIG = \
		{
			0 : "kCfgNoMask",
			0xFF : "kCfgNoMask",
			0x7F : "kCfg7F",
		}
		MAP_FUSES = \
		{
			0 : "kFuseNoMask",
			0x1 : "kFuse01",
			0x3 : "kFuse03",
			0x7 : "kFuse07",
			0xF : "kFuseNoMask",
			0x1F : "kFuse1F",
		}
		MAP_SUBVERSION_PRES = \
		{
			0 : "kNoSubversion",
			1 : "kUseSubversion",
		}
		MAP_SELF_PRES = \
		{
			0 : "kNoSelf",
			1 : "kUseSelf",
		}
		MAP_REVISION_PRES = \
		{
			0 : "kNoRevision",
			1 : "kUseRevision",
		}
		MAP_CONFIG_PRES = \
		{
			0 : "kNoConfig",
			1 : "kUseConfig",
		}
		MAP_FAB_PRES = \
		{
			0 : "kNoFab",
			1 : "kUseFab",
		}
		MAP_FUSES_PRES = \
		{
			0 : "kNoFuses",
			1 : "kUseFuses",
		}
		cfg_cnt = 0
		fh.write("static const Device " + self.id + " =\n{\n")
		if self.ref:
			fh.write("\t&" + self.ref + "\n")
		else:
			fh.write("\tNULL\n")
		if self.name:
			fh.write("\t, \"" + self.name + "\"\n")
		else:
			fh.write("\t, NULL\n")
		if self.lay:
			fh.write("\t, &" + self.lay + "\n")
		else:
			fh.write("\t, NULL\n")
		#
		if self.version is not None:
			fh.write("\t, " + self.version + "\n")
		else:
			fh.write("\t, NO_MCU_ID0\n")
		#
		if self.subversion is not None:
			fh.write("\t, " + extract_lo(self.subversion) + "\n")
			fh.write("\t, " + extract_hi(self.subversion) + "\n")
			cfg_cnt += 2
		if self.self_ is not None:
			fh.write("\t, " + extract_lo(self.self_) + "\n")
			fh.write("\t, " + extract_hi(self.self_) + "\n")
			cfg_cnt += 2
		if self.revision is not None:
			fh.write("\t, " + self.revision + "\n")
			cfg_cnt += 1
		if self.config is not None:
			fh.write("\t, " + self.config + "\n")
			cfg_cnt += 1
		if self.fab is not None:
			fh.write("\t, " + self.fab + "\n")
			cfg_cnt += 1
		if self.fuses is not None:
			fh.write("\t, " + self.fuses + "\n")
			cfg_cnt += 1
		if cfg_cnt > 4:
			raise Exception("Too many identification bytes for " + self.id)
		while cfg_cnt < 4:
			fh.write("\t, EMPTY_INFO_SLOT\n")
			cfg_cnt += 1
		#
		self.put_mask_(fh, self.mfuses, MAP_FUSES)
		self.put_mask_(fh, self.mconfig, MAP_CONFIG)
		#
		self.put_bool_mask_(fh, self.subversion, MAP_SUBVERSION_PRES)
		self.put_bool_mask_(fh, self.self_, MAP_SELF_PRES)
		self.put_bool_mask_(fh, self.revision, MAP_REVISION_PRES)
		self.put_bool_mask_(fh, self.config, MAP_CONFIG_PRES)
		self.put_bool_mask_(fh, self.fab, MAP_FAB_PRES)
		self.put_bool_mask_(fh, self.fuses, MAP_FUSES_PRES)
		#
		if self.bits:
			fh.write("\t, k" + self.bits + "\n")
		else:
			fh.write("\t, kNullBitSize\n")
		if self.arch:
			fh.write("\t, k" + self.arch + "\n")
		else:
			fh.write("\t, kNullArchitecture\n")
		#
		if self.psa:
			fh.write("\t, k" + self.psa + "\n")
		else:
			fh.write("\t, kNullPsaType\n")
		#
		fh.write("};\n")


class DeviceList (object):
	def __init__(self, root, lays, mems):
		super().__init__()
		self.Devs = []
		self.AddNode(root, lays, mems)

	def AddNode(self, node, lays, mems):
		for child in node:
			if child.tag == 'device':
				d = Device(child, self.Devs, lays, mems);
				if d.id is None:
					raise Exception("Failed to resolve id for node " + d.name)
				self.Devs.append(d)

	def DoHfile(self, fh=sys.stdout):
		cnt = 0
		for n in self.Devs:
			n.DoHfile(fh)
			if n.name:
				cnt += 1
		devs = copy.copy(self.Devs)
		devs.sort()
		fh.write("\nconst DeviceList all_msp430_mcus =\n{\n");
		fh.write("\t" + str(cnt) + "\n")
		for n in devs:
			if n.name:
				fh.write("\t, &{}\t// {} {}:{}\n".format(n.id, n.name, n.version, n.revision or n.subversion or n.config or "?"))
		fh.write("};\n\n")



defs = ET.parse("../ExtractChipInfo/MSP430-devices/devices/defaults.xml")
o = Memories(defs.getroot())
l = MemoryLayouts(defs.getroot(), o)
d = DeviceList(defs.getroot(), l, o)

for fname in os.listdir("../ExtractChipInfo/MSP430-devices/devices"):
	if fname in ("defaults.xml", "p401x.xml", "legacy.xml"):
		continue
	print(fname)
	xml = ET.parse("../ExtractChipInfo/MSP430-devices/devices/" + fname)
	o.AddNode(xml.getroot())
	l.AddNode(xml.getroot(), o)
	d.AddNode(xml.getroot(), l, o)

print("\nOptimized {} memory records".format(len(o.Alias)))
print("Optimized {} memory layout records".format(len(l.Alias)))

with open("../BMP430/ChipInfoDB.h", 'w') as fh:
	DoHfileStart(fh)
	o.DoHfile(fh)
	l.DoHfile(fh)
	d.DoHfile(fh)
	DoHfileStop(fh)


